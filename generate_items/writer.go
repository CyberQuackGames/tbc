package main

import (
	"fmt"
	"github.com/wowsims/tbc/generate_items/api"
	"os"
	"regexp"
	"strings"
)

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func ToSnakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

// Converts api.Spec_SpecElementalShaman into 'elemental_shaman'
func SpecToFileName(spec *api.Spec) string {
	if spec == nil {
		return "all"
	}

	return ToSnakeCase(spec.String()[4:])
}

func specInSlice(a api.Spec, list []api.Spec) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

func writeItemFile(outDir string, itemDeclarations []ItemDeclaration, itemResponses []WowheadItemResponse, spec *api.Spec) {
	err := os.MkdirAll(outDir, os.ModePerm)
	if err != nil {
		panic(err)
	}

	file, err := os.Create(fmt.Sprintf("%s/%s.go", outDir, SpecToFileName(spec)))
	if err != nil {
		panic(err)
	}
	defer file.Close()

	file.WriteString("// DO NOT EDIT. This file is auto-generated by the item generator tool. Use that to make edits.\n\n")
	file.WriteString("package items\n\n")
	file.WriteString("import (\n")
	file.WriteString("\t\"github.com/wowsims/tbc/generate_items/api\"\n")
	file.WriteString(")\n\n")
	file.WriteString("var items = []Item{\n")

	for idx, itemDeclaration := range itemDeclarations {
		if spec == nil || specInSlice(*spec, itemDeclaration.Specs) {
			itemResponse := itemResponses[idx]
			file.WriteString(fmt.Sprintf("\t%s,\n", itemToGoString(itemDeclaration, itemResponse)))
		}
	}

	file.WriteString("}\n")

	file.Sync()
}

func itemToGoString(itemDeclaration ItemDeclaration, itemResponse WowheadItemResponse) string {
	itemStr := "{"

	itemStr += fmt.Sprintf("Name:\"%s\", ", itemResponse.Name)
	itemStr += fmt.Sprintf("ID:%d, ", itemDeclaration.ID)

	if itemDeclaration.EffectDataName != "" {
		itemStr += fmt.Sprintf("EffectData:%s, ", itemDeclaration.EffectDataName)
	}

	itemStr += fmt.Sprintf("Type:api.ItemType_%s, ", itemResponse.GetItemType().String())

	armorType := itemResponse.GetArmorType()
	if armorType != api.ArmorType_ArmorTypeUnknown {
		itemStr += fmt.Sprintf("ArmorType:api.ArmorType_%s, ", armorType.String())
	}

	weaponType := itemResponse.GetWeaponType()
	if weaponType != api.WeaponType_WeaponTypeUnknown {
		itemStr += fmt.Sprintf("WeaponType:api.WeaponType_%s, ", weaponType.String())

		handType := itemResponse.GetHandType()
		if handType == api.HandType_HandTypeUnknown {
			panic("Unknown hand type for item: " + itemResponse.Tooltip)
		}
		itemStr += fmt.Sprintf("HandType:api.HandType_%s, ", handType.String())
	} else {
		rangedWeaponType := itemResponse.GetRangedWeaponType()
		if rangedWeaponType != api.RangedWeaponType_RangedWeaponTypeUnknown {
			itemStr += fmt.Sprintf("RangedWeaponType:api.RangedWeaponType_%s, ", rangedWeaponType.String())
		}
	}

	itemStr += fmt.Sprintf("Phase:%d, ", itemResponse.GetPhase())
	itemStr += fmt.Sprintf("Quality:api.ItemQuality_%s, ", api.ItemQuality(itemResponse.Quality).String())

	itemStr += fmt.Sprintf("Stats:%s, ", statsToGoString(itemResponse.GetStats()))

	gemSockets := itemResponse.GetGemSockets()
	if len(gemSockets) > 0 {
		itemStr += "GemSlots:[]GemColor{"
		for _, gemColor := range gemSockets {
			itemStr += fmt.Sprintf("api.GemColor_%s,", gemColor.String())
		}
		itemStr += "}, "
	}

	itemStr += fmt.Sprintf("SocketBonus:%s", statsToGoString(itemResponse.GetSocketBonus()))

	itemStr += "}"
	return itemStr
}

func statsToGoString(stats Stats) string {
	statsStr := "Stats{"

	for stat, value := range stats {
		if value > 0 {
			statsStr += fmt.Sprintf("api.Stat_%s:%.0f,", api.Stat(stat).String(), value)
		}
	}

	statsStr += "}"
	return statsStr
}
