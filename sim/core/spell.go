package core

import (
	"fmt"
	"time"

	"github.com/wowsims/tbc/sim/core/stats"
)

// SimpleSpell has a single cast and could have a dot or direct effect (or no effect)
//  A SimpleSpell without a target or effect will simply be cast and nothing else happens.
type SimpleSpell struct {
	// Embedded spell cast.
	SpellCast

	// Maximum amount of pre-crit damage this spell is allowed to do.
	AOECap float64
}

// Init will call any 'OnCast' effects associated with the caster and then apply spell haste to the cast.
//  Init will panic if the spell or the GCD is still on CD.
func (spell *SimpleSpell) Init(sim *Simulation) {
	spell.SpellCast.init(sim)
}

func (spell *SimpleSpell) GetDuration() time.Duration {
	return spell.CastTime + spell.ChannelTime
}

func (instance *SimpleSpell) Cast(sim *Simulation, target *Target, spell *Spell) bool {
	return instance.startCasting(sim, func(sim *Simulation, cast *Cast) {
		spell.Casts++
		spell.MostRecentCost = cast.Cost.Value
		spell.MostRecentBaseCost = cast.BaseCost.Value

		spell.Instance.objectInUse = false
		spell.ApplyEffects(sim, target, spell)
	})
}

func applyAOECap(effects []SpellEffect, aoeCap float64) {
	// Increased damage from crits doesn't count towards the cap, so need to
	// tally pre-crit damage.
	totalTowardsCap := 0.0
	for i, _ := range effects {
		effect := &effects[i]
		totalTowardsCap += effect.Damage
	}

	if totalTowardsCap <= aoeCap {
		return
	}

	maxDamagePerHit := aoeCap / float64(len(effects))
	for i, _ := range effects {
		effect := &effects[i]
		damageTowardsCap := effect.Damage
		if damageTowardsCap > maxDamagePerHit {
			effect.Damage -= damageTowardsCap - maxDamagePerHit
		}
	}
}

func (instance *SimpleSpell) Cancel(sim *Simulation) {
	instance.SpellCast.Cancel()
}

type ModifySpellCast func(*Simulation, *Target, *SimpleSpell)
type ApplySpellEffects func(*Simulation, *Target, *Spell)

type SpellConfig struct {
	// See definition of Spell (below) for comments on these.
	ActionID
	Character    *Character
	SpellSchool  SpellSchool
	SpellExtras  SpellExtras
	ResourceType stats.Stat
	BaseCost     float64

	Template SimpleSpell

	Cast       CastConfig
	ModifyCast ModifySpellCast

	ApplyEffects ApplySpellEffects
}

type SpellMetrics struct {
	// Metric totals for this spell, for the current iteration.
	Casts              int32
	Misses             int32
	Hits               int32
	Crits              int32
	Dodges             int32
	Glances            int32
	Parries            int32
	Blocks             int32
	PartialResists_1_4 int32   // 1/4 of the spell was resisted
	PartialResists_2_4 int32   // 2/4 of the spell was resisted
	PartialResists_3_4 int32   // 3/4 of the spell was resisted
	TotalDamage        float64 // Damage done by all casts of this spell.
	TotalThreat        float64 // Threat generated by all casts of this spell.
}

type Spell struct {
	// ID for this spell.
	ActionID

	// The character who will perform this spell.
	Character *Character

	// Fire, Frost, Shadow, etc.
	SpellSchool SpellSchool

	// Flags
	SpellExtras SpellExtras

	// Should be stats.Mana, stats.Energy, stats.Rage, or unset.
	ResourceType stats.Stat

	// Base cost. Many effects in the game which 'reduce mana cost by X%'
	// are calculated using the base cost.
	BaseCost float64

	// Default cast parameters with all static effects applied.
	DefaultCast NewCast

	// Performs a cast of this spell.
	castFn CastSuccessFunc

	SpellMetrics

	ModifyCast   ModifySpellCast
	ApplyEffects ApplySpellEffects

	// These fields are manipulated when this spell is cast.
	// The amount of resource spent by the most recent cast of this spell.
	// TODO: Find a way to remove this later, as its a bit hacky.
	MostRecentBaseCost float64
	MostRecentCost     float64

	// The current or most recent cast data.
	CurCast NewCast

	// Templates for creating new casts.
	Template SimpleSpell

	// Current instantiation of this spell. Can only be casting 1 instance of this spell at a time.
	Instance SimpleSpell
}

// Metrics for the current iteration
func (spell *Spell) CurDamagePerCast() float64 {
	if spell.Casts == 0 {
		return 0
	} else {
		return spell.TotalDamage / float64(spell.Casts)
	}
}

func (spell *Spell) reset(_ *Simulation) {
	spell.SpellMetrics = SpellMetrics{}
}

func (spell *Spell) doneIteration() {
	spell.Character.Metrics.addSpell(spell)
}

func (spell *Spell) Cast(sim *Simulation, target *Target) bool {
	if spell.castFn != nil {
		return spell.castFn(sim, target)
	} else {
		// Initialize cast from precomputed template.
		instance := &spell.Instance
		if instance.objectInUse {
			panic(fmt.Sprintf("Spell (%s) already in use", instance.ActionID))
		}
		*instance = spell.Template

		if spell.ModifyCast != nil {
			spell.ModifyCast(sim, target, instance)
		}

		instance.Init(sim)
		success := instance.Cast(sim, target, spell)

		spell.MostRecentCost = instance.Cost.Value
		spell.MostRecentBaseCost = instance.BaseCost.Value

		return success
	}
}

// User-provided function for performing a cast of a spell. Should return whether
// the spell was cast (e.g. not blocked by CDs or resources).
//type SpellCast func(*Simulation, *Spell, *Target) bool

// Registers a new spell to the character. Returns the newly created spell.
func (character *Character) RegisterSpell(config SpellConfig) *Spell {
	if len(character.Spellbook) > 100 {
		panic(fmt.Sprintf("Over 100 registered spells when registering %s! There is probably a spell being registered every iteration.", config.Template.ActionID))
	}
	config.Template.Character = character

	spell := &Spell{
		ActionID:     config.ActionID,
		Character:    character,
		SpellSchool:  config.SpellSchool,
		SpellExtras:  config.SpellExtras,
		ResourceType: config.ResourceType,
		BaseCost:     config.BaseCost,

		DefaultCast: config.Cast.DefaultCast,

		ModifyCast:   config.ModifyCast,
		ApplyEffects: config.ApplyEffects,
	}

	if !config.Template.ActionID.IsEmptyAction() {
		spell.ActionID = config.Template.ActionID
		spell.SpellSchool = config.Template.SpellSchool
		spell.SpellExtras = config.Template.SpellExtras
		spell.Template = config.Template
	} else {
		spell.castFn = spell.makeCastFunc(config.Cast, func(sim *Simulation, target *Target) {
			spell.Casts++
			spell.MostRecentCost = spell.CurCast.Cost
			spell.MostRecentBaseCost = spell.BaseCost

			spell.ApplyEffects(sim, target, spell)
		})
	}

	character.Spellbook = append(character.Spellbook, spell)

	return spell
}

// Returns the first registered spell with the given ID, or nil if there are none.
func (character *Character) GetSpell(actionID ActionID) *Spell {
	for _, spell := range character.Spellbook {
		if spell.ActionID.SameAction(actionID) {
			return spell
		}
	}
	return nil
}

// Retrieves an existing spell with the same ID as the config uses, or registers it if there is none.
func (character *Character) GetOrRegisterSpell(config SpellConfig) *Spell {
	registered := character.GetSpell(config.Template.ActionID)
	if registered == nil {
		return character.RegisterSpell(config)
	} else {
		return registered
	}
}

func ApplyEffectFuncAll(effectFuncs []ApplySpellEffects) ApplySpellEffects {
	if len(effectFuncs) == 0 {
		return nil
	} else if len(effectFuncs) == 1 {
		return effectFuncs[0]
	} else {
		return func(sim *Simulation, target *Target, spell *Spell) {
			for _, effectFunc := range effectFuncs {
				effectFunc(sim, target, spell)
			}
		}
	}
}

func ApplyEffectFuncDirectDamage(baseEffect SpellEffect) ApplySpellEffects {
	if baseEffect.BaseDamage.Calculator == nil {
		// Just a hit check.
		return func(sim *Simulation, target *Target, spell *Spell) {
			effect := baseEffect
			effect.Target = target
			effect.init(sim, spell)

			damage := 0.0
			effect.OutcomeApplier(sim, spell, &effect, &damage)
			effect.triggerProcs(sim, spell)
		}
	} else {
		return func(sim *Simulation, target *Target, spell *Spell) {
			effect := baseEffect
			effect.Target = target
			effect.init(sim, spell)

			damage := effect.calculateBaseDamage(sim, spell) * effect.DamageMultiplier
			effect.calcDamageSingle(sim, spell, damage)
			effect.finalize(sim, spell)
		}
	}
}

func ApplyEffectFuncDamageMultiple(baseEffects []SpellEffect) ApplySpellEffects {
	if len(baseEffects) == 0 {
		panic("Multiple damage requires hits")
	} else if len(baseEffects) == 1 {
		return ApplyEffectFuncDirectDamage(baseEffects[0])
	}

	return func(sim *Simulation, _ *Target, spell *Spell) {
		for i, _ := range baseEffects {
			effect := &baseEffects[i]
			effect.init(sim, spell)
			damage := effect.calculateBaseDamage(sim, spell) * effect.DamageMultiplier
			effect.calcDamageSingle(sim, spell, damage)
		}
		for i, _ := range baseEffects {
			effect := &baseEffects[i]
			effect.finalize(sim, spell)
		}
	}
}
func ApplyEffectFuncDamageMultipleTargeted(baseEffects []SpellEffect) ApplySpellEffects {
	if len(baseEffects) == 0 {
		panic("Multiple damage requires hits")
	} else if len(baseEffects) == 1 {
		return ApplyEffectFuncDirectDamage(baseEffects[0])
	}

	return func(sim *Simulation, target *Target, spell *Spell) {
		for i, _ := range baseEffects {
			effect := &baseEffects[i]
			effect.Target = target
			effect.init(sim, spell)
			damage := effect.calculateBaseDamage(sim, spell) * effect.DamageMultiplier
			effect.calcDamageSingle(sim, spell, damage)
		}
		for i, _ := range baseEffects {
			effect := &baseEffects[i]
			effect.finalize(sim, spell)
		}
	}
}
func ApplyEffectFuncAOEDamage(sim *Simulation, baseEffect SpellEffect) ApplySpellEffects {
	numHits := sim.GetNumTargets()
	effects := make([]SpellEffect, 0, numHits)
	for i := int32(0); i < numHits; i++ {
		effects = append(effects, baseEffect)
		effects[i].Target = sim.GetTarget(i)
	}
	return ApplyEffectFuncDamageMultiple(effects)
}

func ApplyEffectFuncDot(dot *Dot) ApplySpellEffects {
	return func(sim *Simulation, _ *Target, _ *Spell) {
		dot.Apply(sim)
	}
}
