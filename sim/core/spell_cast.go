package core

import (
	"fmt"
	"math"

	"github.com/wowsims/tbc/sim/core/stats"
)

// Callback for after a spell hits the target and after damage is calculated. Use it for proc effects
// or anything that comes from the final result of the spell.
type OnSpellHit func(sim *Simulation, spell *Spell, spellEffect *SpellEffect)

// OnPeriodicDamage is called when dots tick, after damage is calculated. Use it for proc effects
// or anything that comes from the final result of a tick.
type OnPeriodicDamage func(sim *Simulation, spell *Spell, spellEffect *SpellEffect, tickDamage float64)

// A Spell is a type of cast that can hit/miss using spell stats, and has a spell school.
type SpellCast struct {
	// Embedded Cast
	Cast
}

type SpellEffect struct {
	// Target of the spell.
	Target *Target

	BaseDamage BaseDamageConfig
	DotInput   DotDamageInput

	// Bonus stats to be added to the spell.
	BonusSpellHitRating  float64
	BonusSpellPower      float64
	BonusSpellCritRating float64

	BonusAttackPower float64
	BonusCritRating  float64

	// Additional multiplier that is always applied.
	DamageMultiplier float64

	// Multiplier for all threat generated by this effect.
	ThreatMultiplier float64

	// Adds a fixed amount of threat to this spell, before multipliers.
	FlatThreatBonus float64

	// Whether this is a phantom cast. Phantom casts are usually casts triggered by some effect,
	// like The Lightning Capacitor or Shaman Flametongue Weapon. Many on-hit effects do not
	// proc from phantom casts, only regular casts.
	IsPhantom bool

	OutcomeRollCategory OutcomeRollCategory
	CritRollCategory    CritRollCategory

	// How much to multiply damage by, if this cast crits.
	CritMultiplier float64

	// Controls which effects can proc from this effect.
	ProcMask ProcMask

	// Callbacks for providing additional custom behavior.
	OnSpellHit OnSpellHit

	// Results
	Outcome HitOutcome
	Damage  float64 // Damage done by this cast.
	Threat  float64

	// Certain damage multiplier, such as target debuffs and crit multipliers, do
	// not count towards the AOE cap. Store them here to they can be subtracted
	// later when calculating AOE cap.
	BeyondAOECapMultiplier float64
}

func (spellEffect *SpellEffect) Landed() bool {
	return spellEffect.Outcome.Matches(OutcomeLanded)
}

func (spellEffect *SpellEffect) TotalThreatMultiplier(character *Character) float64 {
	return spellEffect.ThreatMultiplier * character.PseudoStats.ThreatMultiplier
}

func (spellEffect *SpellEffect) calcThreat(character *Character) float64 {
	if spellEffect.Landed() {
		return (spellEffect.Damage + spellEffect.FlatThreatBonus) * spellEffect.TotalThreatMultiplier(character)
	} else {
		return 0
	}
}

func (spellEffect *SpellEffect) MeleeAttackPower(character *Character) float64 {
	return character.stats[stats.AttackPower] + character.PseudoStats.MobTypeAttackPower + spellEffect.BonusAttackPower
}

func (spellEffect *SpellEffect) MeleeAttackPowerOnTarget() float64 {
	return spellEffect.Target.PseudoStats.BonusMeleeAttackPower
}

func (spellEffect *SpellEffect) RangedAttackPower(character *Character) float64 {
	return character.stats[stats.RangedAttackPower] + character.PseudoStats.MobTypeAttackPower + spellEffect.BonusAttackPower
}

func (spellEffect *SpellEffect) RangedAttackPowerOnTarget() float64 {
	return spellEffect.Target.PseudoStats.BonusRangedAttackPower
}

func (spellEffect *SpellEffect) BonusWeaponDamage(character *Character) float64 {
	return character.PseudoStats.BonusDamage
}

func (spellEffect *SpellEffect) PhysicalHitChance(character *Character) float64 {
	hitRating := character.stats[stats.MeleeHit] + spellEffect.Target.PseudoStats.BonusMeleeHitRating

	if spellEffect.OutcomeRollCategory.Matches(OutcomeRollCategoryRanged) {
		hitRating += character.PseudoStats.BonusRangedHitRating
	}

	return (hitRating / (MeleeHitRatingPerHitChance * 100)) - spellEffect.Target.HitSuppression
}

func (spellEffect *SpellEffect) PhysicalCritChance(character *Character, spell *Spell) float64 {
	critRating := character.stats[stats.MeleeCrit] + spellEffect.BonusCritRating + spellEffect.Target.PseudoStats.BonusCritRating

	if spellEffect.OutcomeRollCategory.Matches(OutcomeRollCategoryRanged) {
		critRating += character.PseudoStats.BonusRangedCritRating
	} else {
		critRating += character.PseudoStats.BonusMeleeCritRating
	}
	if spell.SpellExtras.Matches(SpellExtrasAgentReserved1) {
		critRating += character.PseudoStats.BonusCritRatingAgentReserved1
	}
	if spellEffect.ProcMask.Matches(ProcMaskMeleeMH) {
		spellEffect.BonusCritRating += character.PseudoStats.BonusMHCritRating
	} else if spellEffect.ProcMask.Matches(ProcMaskMeleeOH) {
		spellEffect.BonusCritRating += character.PseudoStats.BonusOHCritRating
	}

	return (critRating / (MeleeCritRatingPerCritChance * 100)) - spellEffect.Target.CritSuppression
}

func (spellEffect *SpellEffect) SpellPower(character *Character, spell *Spell) float64 {
	return character.GetStat(stats.SpellPower) + character.GetStat(spell.SpellSchool.Stat()) + character.PseudoStats.MobTypeSpellPower + spellEffect.BonusSpellPower
}

func (spellEffect *SpellEffect) SpellCritChance(character *Character, spell *Spell) float64 {
	critRating := (character.GetStat(stats.SpellCrit) + spellEffect.BonusSpellCritRating + spellEffect.Target.PseudoStats.BonusCritRating)
	if spell.SpellSchool.Matches(SpellSchoolFire) {
		critRating += character.PseudoStats.BonusFireCritRating
	} else if spell.SpellSchool.Matches(SpellSchoolFrost) {
		critRating += spellEffect.Target.PseudoStats.BonusFrostCritRating
	}
	return critRating / (SpellCritRatingPerCritChance * 100)
}

func (spellEffect *SpellEffect) directCalculations(sim *Simulation, spell *Spell) {
	damage := spellEffect.calculateBaseDamage(sim, spell)

	damage *= spellEffect.DamageMultiplier
	spellEffect.applyAttackerModifiers(sim, spell, false, &damage)
	spellEffect.applyTargetModifiers(sim, spell, false, spellEffect.BaseDamage.TargetSpellCoefficient, &damage)
	spellEffect.applyResistances(sim, spell, &damage)
	spellEffect.applyOutcome(sim, spell, &damage)

	spellEffect.Damage = damage
}

func (spellEffect *SpellEffect) calculateBaseDamage(sim *Simulation, spell *Spell) float64 {
	if spellEffect.BaseDamage.Calculator == nil {
		return 0
	} else {
		return spellEffect.BaseDamage.Calculator(sim, spellEffect, spell)
	}
}

func (spellEffect *SpellEffect) determineOutcome(sim *Simulation, spell *Spell, isPeriodic bool) {
	if isPeriodic {
		if spellEffect.DotInput.TicksCanMissAndCrit {
			if spellEffect.hitCheck(sim, spell) {
				spellEffect.Outcome = OutcomeHit
				if spellEffect.critCheck(sim, spell) {
					spellEffect.Outcome = OutcomeCrit
				}
			} else {
				spellEffect.Outcome = OutcomeMiss
			}
		} else {
			spellEffect.Outcome = OutcomeHit
		}
		return
	}

	if spellEffect.OutcomeRollCategory == OutcomeRollCategoryNone || spell.SpellExtras.Matches(SpellExtrasAlwaysHits) {
		spellEffect.Outcome = OutcomeHit
		if spellEffect.critCheck(sim, spell) {
			spellEffect.Outcome = OutcomeCrit
		}
	} else if spellEffect.OutcomeRollCategory.Matches(OutcomeRollCategoryMagic) {
		if spellEffect.hitCheck(sim, spell) {
			spellEffect.Outcome = OutcomeHit
			if spellEffect.critCheck(sim, spell) {
				spellEffect.Outcome = OutcomeCrit
			}
		} else {
			spellEffect.Outcome = OutcomeMiss
		}
	} else if spellEffect.OutcomeRollCategory.Matches(OutcomeRollCategoryPhysical) {
		spellEffect.Outcome = spellEffect.WhiteHitTableResult(sim, spell)
		if spellEffect.Landed() && spellEffect.critCheck(sim, spell) {
			spellEffect.Outcome = OutcomeCrit
		}
	}
}

// Computes an attack result using the white-hit table formula (single roll).
func (ahe *SpellEffect) WhiteHitTableResult(sim *Simulation, spell *Spell) HitOutcome {
	character := spell.Character

	roll := sim.RandomFloat("White Hit Table")

	// Miss
	missChance := ahe.Target.MissChance - ahe.PhysicalHitChance(character)
	if character.AutoAttacks.IsDualWielding && ahe.OutcomeRollCategory == OutcomeRollCategoryWhite {
		missChance += 0.19
	}
	missChance = MaxFloat(0, missChance)

	chance := missChance
	if roll < chance {
		return OutcomeMiss
	}

	if !ahe.OutcomeRollCategory.Matches(OutcomeRollCategoryRanged) { // Ranged hits can't be dodged/glance, and are always 2-roll
		// Dodge
		if !spell.SpellExtras.Matches(SpellExtrasCannotBeDodged) {
			dodge := ahe.Target.Dodge

			expertiseRating := character.stats[stats.Expertise]
			if ahe.ProcMask.Matches(ProcMaskMeleeMH) {
				expertiseRating += character.PseudoStats.BonusMHExpertiseRating
			} else if ahe.ProcMask.Matches(ProcMaskMeleeOH) {
				expertiseRating += character.PseudoStats.BonusOHExpertiseRating
			}
			expertisePercentage := MinFloat(math.Floor(expertiseRating/ExpertisePerQuarterPercentReduction)/400, dodge)

			chance += dodge - expertisePercentage
			if roll < chance {
				return OutcomeDodge
			}
		}

		// Parry (if in front)
		// If the target is a mob and defense minus weapon skill is 11 or more:
		// ParryChance = 5% + (TargetLevel*5 - AttackerSkill) * 0.6%

		// If the target is a mob and defense minus weapon skill is 10 or less:
		// ParryChance = 5% + (TargetLevel*5 - AttackerSkill) * 0.1%

		// Block (if in front)
		// If the target is a mob:
		// BlockChance = MIN(5%, 5% + (TargetLevel*5 - AttackerSkill) * 0.1%)
		// If we actually implement blocks, ranged hits can be blocked.

		// No need to crit/glance roll if we are not a white hit
		if ahe.OutcomeRollCategory.Matches(OutcomeRollCategorySpecial | OutcomeRollCategoryRanged) {
			return OutcomeHit
		}

		// Glance
		chance += ahe.Target.Glance
		if roll < chance {
			return OutcomeGlance
		}

		// Crit
		chance += ahe.PhysicalCritChance(character, spell)
		if roll < chance {
			return OutcomeCrit
		}
	}

	return OutcomeHit
}

// Calculates a hit check using the stats from this spell.
func (spellEffect *SpellEffect) hitCheck(sim *Simulation, spell *Spell) bool {
	hit := 0.83 + (spell.Character.GetStat(stats.SpellHit)+spellEffect.BonusSpellHitRating)/(SpellHitRatingPerHitChance*100)
	hit = MinFloat(hit, 0.99) // can't get away from the 1% miss

	return sim.RandomFloat("Magical Hit Roll") < hit
}

// Calculates a crit check using the stats from this spell.
func (spellEffect *SpellEffect) critCheck(sim *Simulation, spell *Spell) bool {
	switch spellEffect.CritRollCategory {
	case CritRollCategoryMagical:
		critChance := spellEffect.SpellCritChance(spell.Character, spell)
		return sim.RandomFloat("Magical Crit Roll") < critChance
	case CritRollCategoryPhysical:
		return sim.RandomFloat("Physical Crit Roll") < spellEffect.PhysicalCritChance(spell.Character, spell)
	default:
		return false
	}
}

func (spellEffect *SpellEffect) afterCalculations(sim *Simulation, spell *Spell, isPeriodic bool) {
	spellEffect.applyResultsToSpell(spell, isPeriodic && !spellEffect.DotInput.TicksCanMissAndCrit)

	if sim.Log != nil && !(spell.SpellExtras.Matches(SpellExtrasAlwaysHits) && spellEffect.Damage == 0) {
		if isPeriodic {
			spell.Character.Log(sim, "%s tick %s. (Threat: %0.3f)", spell.ActionID, spellEffect, spellEffect.calcThreat(spell.Character))
		} else {
			spell.Character.Log(sim, "%s %s. (Threat: %0.3f)", spell.ActionID, spellEffect, spellEffect.calcThreat(spell.Character))
		}
	}

	if !isPeriodic || spellEffect.DotInput.TicksProcSpellEffects {
		if spellEffect.OnSpellHit != nil {
			spellEffect.OnSpellHit(sim, spell, spellEffect)
		}
		spell.Character.OnSpellHit(sim, spell, spellEffect)
		spellEffect.Target.OnSpellHit(sim, spell, spellEffect)
	}

	if isPeriodic {
		spell.Character.OnPeriodicDamage(sim, spell, spellEffect, spellEffect.Damage)
		spellEffect.Target.OnPeriodicDamage(sim, spell, spellEffect, spellEffect.Damage)
		if spellEffect.DotInput.OnPeriodicDamage != nil {
			spellEffect.DotInput.OnPeriodicDamage(sim, spell, spellEffect, spellEffect.Damage)
		}
	}
}

func (spellEffect *SpellEffect) applyResultsToSpell(spell *Spell, isPeriodic bool) {
	if !isPeriodic {
		if spellEffect.Outcome.Matches(OutcomeHit) {
			spell.Hits++
		}
		if spellEffect.Outcome.Matches(OutcomeGlance) {
			spell.Glances++
		}
		if spellEffect.Outcome.Matches(OutcomeCrit) {
			spell.Crits++
		}
		if spellEffect.Outcome.Matches(OutcomeBlock) {
			spell.Blocks++
		}

		if spellEffect.Landed() {
			if spellEffect.Outcome.Matches(OutcomePartial1_4) {
				spell.PartialResists_1_4++
			} else if spellEffect.Outcome.Matches(OutcomePartial2_4) {
				spell.PartialResists_2_4++
			} else if spellEffect.Outcome.Matches(OutcomePartial3_4) {
				spell.PartialResists_3_4++
			}
		} else {
			if spellEffect.Outcome == OutcomeMiss {
				spell.Misses++
			} else if spellEffect.Outcome == OutcomeDodge {
				spell.Dodges++
			} else if spellEffect.Outcome == OutcomeParry {
				spell.Parries++
			}
		}
	}

	spell.TotalDamage += spellEffect.Damage
	spell.TotalThreat += spellEffect.calcThreat(spell.Character)
}

func (spellEffect *SpellEffect) String() string {
	outcomeStr := spellEffect.Outcome.String()
	if !spellEffect.Landed() {
		return outcomeStr
	}
	return fmt.Sprintf("%s for %0.3f damage", outcomeStr, spellEffect.Damage)
}

func (spellEffect *SpellEffect) applyAttackerModifiers(sim *Simulation, spell *Spell, isPeriodic bool, damage *float64) {
	attacker := spell.Character

	if spellEffect.OutcomeRollCategory.Matches(OutcomeRollCategoryRanged) {
		*damage *= attacker.PseudoStats.RangedDamageDealtMultiplier
	}
	if spell.SpellExtras.Matches(SpellExtrasAgentReserved1) {
		*damage *= attacker.PseudoStats.AgentReserved1DamageDealtMultiplier
	}

	*damage *= attacker.PseudoStats.DamageDealtMultiplier
	if spell.SpellSchool.Matches(SpellSchoolPhysical) {
		*damage *= attacker.PseudoStats.PhysicalDamageDealtMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolArcane) {
		*damage *= attacker.PseudoStats.ArcaneDamageDealtMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolFire) {
		*damage *= attacker.PseudoStats.FireDamageDealtMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolFrost) {
		*damage *= attacker.PseudoStats.FrostDamageDealtMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolHoly) {
		*damage *= attacker.PseudoStats.HolyDamageDealtMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolNature) {
		*damage *= attacker.PseudoStats.NatureDamageDealtMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolShadow) {
		*damage *= attacker.PseudoStats.ShadowDamageDealtMultiplier
	}
}

func (spellEffect *SpellEffect) applyTargetModifiers(sim *Simulation, spell *Spell, isPeriodic bool, targetCoeff float64, damage *float64) {
	target := spellEffect.Target

	*damage *= target.PseudoStats.DamageTakenMultiplier
	if spell.SpellSchool.Matches(SpellSchoolPhysical) {
		if targetCoeff > 0 {
			*damage += target.PseudoStats.BonusPhysicalDamageTaken
		}
		*damage *= target.PseudoStats.PhysicalDamageTakenMultiplier
		if isPeriodic {
			*damage *= target.PseudoStats.PeriodicPhysicalDamageTakenMultiplier
		}
	} else if spell.SpellSchool.Matches(SpellSchoolArcane) {
		*damage *= target.PseudoStats.ArcaneDamageTakenMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolFire) {
		*damage *= target.PseudoStats.FireDamageTakenMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolFrost) {
		*damage *= target.PseudoStats.FrostDamageTakenMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolHoly) {
		*damage += target.PseudoStats.BonusHolyDamageTaken * targetCoeff
		*damage *= target.PseudoStats.HolyDamageTakenMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolNature) {
		*damage *= target.PseudoStats.NatureDamageTakenMultiplier
	} else if spell.SpellSchool.Matches(SpellSchoolShadow) {
		*damage *= target.PseudoStats.ShadowDamageTakenMultiplier
	}
}

// Modifies damage based on Armor or Magic resistances, depending on the damage type.
func (spellEffect *SpellEffect) applyResistances(sim *Simulation, spell *Spell, damage *float64) {
	if spell.SpellExtras.Matches(SpellExtrasIgnoreResists) {
		return
	}

	if spell.SpellSchool.Matches(SpellSchoolPhysical) {
		// Physical resistance (armor).
		*damage *= 1 - spellEffect.Target.ArmorDamageReduction(spell.Character.stats[stats.ArmorPenetration])
	} else if !spell.SpellExtras.Matches(SpellExtrasBinary) {
		// Magical resistance.
		// https://royalgiraffe.github.io/resist-guide

		resistanceRoll := sim.RandomFloat("Partial Resist")
		if resistanceRoll > 0.18 { // 13% chance for 25% resist, 4% for 50%, 1% for 75%
			// No partial resist.
		} else if resistanceRoll > 0.05 {
			spellEffect.Outcome |= OutcomePartial1_4
			*damage *= 0.75
		} else if resistanceRoll > 0.01 {
			spellEffect.Outcome |= OutcomePartial2_4
			*damage *= 0.5
		} else {
			spellEffect.Outcome |= OutcomePartial3_4
			*damage *= 0.25
		}
	}
}

func (spellEffect *SpellEffect) applyOutcome(sim *Simulation, spell *Spell, damage *float64) {
	if !spellEffect.Landed() {
		*damage = 0
	} else if spellEffect.Outcome.Matches(OutcomeCrit) {
		*damage *= spellEffect.CritMultiplier
	} else if spellEffect.Outcome == OutcomeGlance {
		// TODO glancing blow damage reduction is actually a range ([65%, 85%] vs. 73)
		*damage *= 0.75
	}
}
